\documentclass[12pt,reqno,final]{amsart}
\usepackage[round,numbers,sort&compress]{natbib}
\usepackage{graphicx}
\usepackage{times}
\usepackage{rotating}
\usepackage{subfig}

\title[]{}

\setlength{\textwidth}{6.25in}
\setlength{\textheight}{8.75in}
\setlength{\evensidemargin}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\topmargin}{-.35in}
\setlength{\parskip}{.1in}
\setlength{\parindent}{0.0in}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{corol}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{defn}[thm]{Definition}
\newtheorem{hyp}[thm]{Hypothesis}
\newtheorem{example}[thm]{Example}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{algorithm}[thm]{Algorithm}
\newtheorem{remark}{Remark}
\renewcommand\thethm{\arabic{thm}}
\renewcommand{\theremark}{}

\numberwithin{equation}{part}
\renewcommand\theequation{\arabic{equation}}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thefigure{\arabic{figure}}
\renewcommand\thetable{\arabic{table}}
\renewcommand\thefootnote{\arabic{footnote}}

\begin{document}

\maketitle

This documents my exploration of the differences between \texttt{OUwie} and \texttt{ouch} when each is asked to fit OU models with a single $\alpha$ and $\sigma$ operating on the entire tree.
The motivation for this is that I noticed that the parameter estimates and likelihoods reached by \texttt{OUwie} and \texttt{ouch} are often quite different.
I originally did this is 2014, but wanted to update it now to explore how the programs differ from one another now.

The procedure I will follow here is very straightforward: generate Yule trees of different sizes; specify two selective regimes arising out of the branching event at the root, so that there is a single monophyletic clade in each selective regime - this is the simplest possible multiple-optimum OU scenario; simulate phenotypic data with a known $\alpha$ and $\sigma$; fit an OU model to the phenotypic data and tree using both \texttt{OUwie} and \texttt{ouch} and record the
parameter estimates and likelihoods.

Trees were generated by assuming that branching follows a Poisson process, so that branching events are exponentially distributed. To generate trees of different sizes, I set the rate parameter of the exponential distribution to a value of 0.3 and found random number generator seeds that would generate trees of size from 10 to 100 tips, with the only constraint being that the smaller of the two clades originating at the root had at least 1/3 of the total tip species.
This guarantees that both selective regimes are reasonably well-represented, thereby improving both power and parameter estimates.

Phenotypic data was generated assuming $\alpha=3$ and $\sigma^2=1$, with selective optima of $\theta_1=-1$ and $\theta_2=1$. The root was always assumed to be in regime 1. For any given tree size, 20 different phenotypic datasets were generated and fit to the OU model.
This allows me to calculate how bias/variance in parameter estimates differ between the two algorithms.
All of the code, including random number generator seeds, needed to reproduce the results shown here can be found at the end of this document.

<<echo=F,fig.cap="Comparing the $\\alpha$ estimates of \\texttt{ouch} and \\texttt{OUwie} for trees of 10-100 tips. In the top panel, the lines and shaded region come from fitting a generalized additive model to the $\\alpha$ estimates, with the size of the tree as the dependent variable. The line shows the expectation of the GAM, whereas the shaded regions capture the variability across the 20 stochastically generated phenotypic datasets. The black line shows the true $\\alpha$ value. From this figure, it appears that the estimates are converging on the true value, but the error around the \\texttt{ouch} estimates is higher than for \\texttt{OUwie}. However, an examination of the estimates for each dataset (bottom panels) shows that variability is actually still fairly large. It is clear, however, that neither method is particularly good or bad at estimating $\\alpha$. If anything, \\texttt{OUwie} is slightly better than \\texttt{ouch}, which is a change from 2014, when I did this analysis.", fig.height=6, fig.width=5, units='in'>>=
require(ggplot2)
require(patchwork)
load(file='Comparing_OUwie_and_ouch_results.rda')
##
alpha <- data.frame(alpha=c(results$ouch.alpha,results$ouwie.alpha),
                   Tips=rep(results$ntips,2),
                    Model=factor(rep(c('ouch','OUwie'),each=nrow(results))))
alpha2 <- subset(alpha, alpha > 0.1)

p1 <- ggplot(alpha, aes(Tips, alpha, group=Model, colour=Model, fill=Model)) + geom_smooth() + geom_hline(yintercept=3) + theme_bw()
p2 <- ggplot(alpha2, aes(Tips, log10(alpha))) + geom_point() + facet_wrap(~Model) + theme_bw() + geom_hline(yintercept=log10(3), color='red')

p1 + p2 + plot_layout(ncol=1)
@

<<echo=F,fig.cap="Estimates of the discriminability ratio, $\\sqrt{2\\alpha}\\Delta\\theta/\\sigma$ (Cressler, Butler, and King 2015). This dimensionless combination of parameters may be better estimated than any individual parameter. This dimensionless parameter also captures the linked ability to estimate the selective optima, selection strength, and drift. You can see from all three panels that \\texttt{ouch} and \\texttt{OUwie} often estimate this parameter nearly identically: the top panel shows results from a generalized additive model fit to the estimates for each number of tips; the middle panel shows a scatterplot of the estimates for each method; the bottom panel shows a histogram of the difference between the \\texttt{ouch} estimate and the \\texttt{OUwie} estimate. Interestingly, the estimate returned by \\texttt{ouch} is always larger than the estimate returned by \\texttt{OUwie}.", fig.height=6, fig.width=5, units='in'>>=
library(plyr)
mutate(results,
       ouch.discratio=sqrt(2*ouch.alpha)*(ouch.th2-ouch.th1)/sqrt(ouch.sigma.sq),
       ouwie.discratio=sqrt(2*ouwie.alpha)*(ouwie.th2-ouwie.th1)/sqrt(ouwie.sigma.sq),
       discratio.diff=ouch.discratio-ouwie.discratio) -> results

disc <- data.frame(discratio=results$ouch.discratio, results$ouwie.discratio,
                   Tips=rep(results$ntips,2),
                   Model=factor(rep(c('ouch','OUwie'),each=nrow(results))))

p1 <- ggplot(disc, aes(Tips, discratio, group=Model, colour=Model, fill=Model)) + facet_wrap(~Model) + geom_smooth() + geom_hline(yintercept=sqrt(2*3)*2/1) + theme_bw()

p2 <- ggplot(results, aes(ouch.discratio, ouwie.discratio)) + geom_point() + geom_abline(slope=1, intercept=0, colour='orange') + theme_bw()

p3 <- ggplot(results, aes(discratio.diff)) + geom_histogram(binwidth=0.05) + theme_bw()

p1 + p2 + p3 + plot_layout(ncol=1)
@

<<echo=FALSE, fig.cap="Estimated AICs for \\texttt{ouch} and \\texttt{OUwie} are essentially identical. The histogram shows the difference between the AIC of the parameters estimated by \\texttt{ouch} and the AIC of the \\texttt{OUwie} parameter estimates; positive values suggest that \texttt{OUwie} has found parameter estimates with a higher likelihood.", fig.height=4, fig.width=5, units='in'>>=
p1 <- ggplot(results, aes(ouch.aic, ouch.aic)) + geom_point() + geom_abline(slope=1, intercept=0, colour='orange') + theme_bw()
mutate(results,
       aic.diff=ouch.aic-ouwie.aic) -> results
p2 <- ggplot(results, aes(aic.diff)) + geom_histogram(binwidth=0.05) + theme_bw()
p1+p2

@

\newpage

<<echo=TRUE, eval=FALSE>>=
require(ouch)
## Creates an ouchtree object.
##
## 'waittime' must be specified by the user, and is the
## expected time to a branching event, assuming the branching
## follows a Poisson process (that is, that branching events
## are exponentially distributed)
##
## 'endtime' must also be specified and determines how long to
## let the branching process proceed.
##
## The smaller the value of waittime, or the larger the value
## of endtime, the larger the tree that will be produced. If
## only these two variables are set, the tree that is produced
## will be ultrametric; specifically, it will be a Yule tree,
## corresponding to a pure birth process.
##
## 'time' can also be specified, setting the time of the root
## node.

## A birth-death branching process can be simulated by setting
## the value of extrate, which determines the rate at which
## lineages go extinct. This rate is also assumed to be
## exponentially distributed.
##
gen.tree <- function(waittime, endtime,
                     time = 0, extrate = 0,
                     anc.node = NA, tree) {
    if (missing(tree))
        tree <- matrix(NA,0,3,
                       dimnames=list(NULL,c("node","ancestor","time")))
    curr.node <- nrow(tree)+1
    if (time < endtime) {
        tree <- rbind(tree,c(curr.node,anc.node,time))
        extinct.time <- if (extrate > 0) {
            time+rexp(2,rate=extrate)
        } else {
            c(Inf,Inf)
        }
        time <- pmin(time+rexp(2,rate=1/waittime),endtime)
        for (k in 1:2) {
            if (time[k] < extinct.time[k]) {
                tree <- Recall(time=time[k],
                               waittime=waittime,endtime=endtime,extrate=extrate,anc.node=curr.node,tree=tree)
            } else {
                tree <- rbind(tree,c(nrow(tree)+1,curr.node,extinct.time[k]))
            }
        }
    } else {
        tree <- rbind(tree,c(curr.node,anc.node,time))
    }
    return(as.data.frame(tree))
}

## Generate phenotypic data according to an Ornstein-Uhlenbeck
## process, given an ouchtree object specified by tree, regimes
## specified by regimes, and OU parameters theta, alpha, and sigma.
## This is done by recursion, which gen.phenotypic.values acting as
## the "parent" function that calls set.phenotypic.values, the
## function that is recursed over.
gen.phenotypic.values <- function(tree, regimes, theta, alpha, sigma, remove.anc=TRUE) {
  if (class(tree) == 'data.frame')
    tree <- with(tree, ouchtree(node,ancestor,time))
  if (tree@nnodes != length(regimes))
    stop('Length of regime specification != number of nodes in tree; each node in tree must be assigned to a regime')
  if (length(theta) != length(levels(regimes)))
    stop('Each regime must have a unique theta value specified as the selective optima')

  root.reg <- as.numeric(regimes[1])
  root.pheno <- calc.root.pheno(theta[root.reg], alpha, sigma)
  pheno <<- vector(mode='numeric', length=tree@nnodes)
  set.phenotypic.values(curr.node=1, anc.node=0, anc.pheno=root.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)

  ## if T, set the phenotypic values of internal nodes to NA
  if (remove.anc==T)
    pheno[as.numeric(setdiff(tree@nodes, tree@term))] <<- NA

  pheno
}
## Calculate the phenotypic value of the ancestral node as being drawn
## from the stationary distribution of the OU process.
calc.root.pheno <- function(theta, alpha, sigma) {
  ## mean and variance of stationary distribution
  mean <- theta
  var <- sigma^2/(2*alpha)
  rnorm(1, mean=mean, sd=sqrt(var))
}
## This function recursively sets the phenotypic values of the nodes
## in an ouchtree object specified by tree.  The values are, by
## default, set for a vector called 'pheno'
set.phenotypic.values <- function(curr.node, anc.node, anc.pheno, tree, regimes, theta, alpha, sigma) {
  ## set the phenotype of the current node
  if (curr.node == 1) {
    pheno[curr.node] <<- anc.pheno

    ## get the descendents of the root node and set their phenotypes
    desc <- which(tree@ancestors==curr.node)
    Recall(curr.node=desc[1], anc.node=curr.node, anc.pheno=anc.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
    Recall(curr.node=desc[2], anc.node=curr.node, anc.pheno=anc.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
  }
  else {
    ## generate a new phenotypic value
    x0 <- anc.pheno
    t <- as.numeric(tree@times[curr.node])-as.numeric(tree@times[anc.node])
    th <- theta[as.numeric(levels(regimes)[regimes[curr.node]])]
    a <- alpha
    p <- x0*exp(-a*t) + th*(1-exp(-a*t)) +
      sigma*sqrt((1-exp(-2*a*t))/(2*a))*rnorm(1, 0, 1)

    ## set the value of the phenotype
    pheno[curr.node] <<- p

    ## if the curr.node is not a tip, get its ancestors and set their
    ## phenotypes
    if (!(curr.node %in% tree@term)) {
      desc <- which(tree@ancestors==curr.node)

      ## set the phenotypes for all descendents
      for (n in 1:length(desc))
        Recall(curr.node=desc[n], anc.node=curr.node, anc.pheno=p, tree=tree,
               regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
    }
  }
}

run <- FALSE;
if (run) {

    ## RNG seeds used to generate the trees
    seeds <- c(35250,48305,512,9741,10942,82785,3690754,52887,2694830,31665,42307,64469,35257,68441,92488,91977,35279,63427,46032,64842,20056,13808,68427,79904,36216,762795,79173,59583,47372,7590702,90416,73212,33918,99829,35133,83037,34561,1252,77451,21182,68657,80080,58622,23352,92605,61669,94680,70448,62496,86767,50532,32082,6873,52895,52446,59809,50041,69135,87196,16166,35368,6690,57828,532,12679,55138,50109,45607,97207,11457,17776,421650,46569,67892,3646,80656,3812264,78324,88179,2143,3091624,4407,30378,2489714,5983027,57710,13597,10252,91772,70484,4685585)

    ## RNG seeds for generating phenotypic datasets
    pseeds <- c(429561,582711,910097,733148,536289,732902,397913,193437,466449,731455,229950,492461,462732,95019,379477,553164,806700,771928,524934,268107)

    results <- array(NA, dim=c(length(seeds)*length(pseeds),13))
    row <- 1
    for (i in 1:length(seeds)) {
        print(i)
        seed <- seeds[i]
        set.seed(seed)
        tree <- gen.tree(waittime=0.3, endtime=1)
        labels <- rep('', nrow(tree))
        labels[which(tree$time==1)] <- paste0('Sp',1:sum(tree$time==1))
        tree$labels <- labels
        ou.tree <- ouchtree(nodes=tree$node, ancestors=tree$ancestor, times=tree$time, labels=tree$labels)
        ou.reg <- paint(ou.tree, subtree=c('1'='1','2'='2'), branch=c('1'='1', '2'='2'))

        source("convert.R") ## for converting ouchtree to apetree
        ape.tree <- convert(ot=ou.tree)
        ## Label the internal nodes with their regime
        ## figure out which clade is in regime 2
        ## root is ntips+1, find its daughters
        daughters <- which(ape.tree$edge[,1]==ou.tree@nterm+1)
        ## which daughter corresponds to node 2 in the ouchtree?
        node2 <- which(round(ape.tree$edge.length[daughters],4)==round(ou.tree@times[2],4))
        ## what is the nodelabel for this daughter
        start <- ape.tree$edge[daughters[node2],2]
        ## what is the nodelabel for the other daughter?
        finish <- ape.tree$edge[daughters[-node2],2]
        ## create node.labels
        nodes <- (ou.tree@nterm+1):(ape.tree$Nnode+ou.tree@nterm)
        regs <- rep('1', length(nodes))
        reg2 <- start:(finish-1)
        regs[which(nodes%in%reg2)] <- '2'
        ape.tree$node.label <- regs

        ## Plot trees to ensure that the trees and paintings are identical
        ## plot(ou.tree, regimes=ou.reg)
        ## par(ask=T)
        ## plot(ape.tree)
        ## nodelabels(pch=21, bg=ape.tree$node.label)

        for (j in 1:length(pseeds)) {
            set.seed(pseeds[j])
            ## simulate phenotypic data
            x <- gen.phenotypic.values(ou.tree, ou.reg, theta=c(-1,1), alpha=3, sigma=1)
            ## create data frames of phenotypic data
            ou.dat <- data.frame(val=x)
            ape.dat <- as(ou.tree, 'data.frame')[,c(4,1,2,3)]
            ape.dat$val <- x
            ape.dat$reg <- ou.reg
            ape.dat <- ape.dat[!is.na(ape.dat$val),c('labels','reg','val')]

            ## fit OU model using ouch and OUwie and record
            ou.OU <- hansen(ou.dat, ou.tree, ou.reg, sqrt.alpha=1, sigma=1)
            ape.OUM <- OUwie(ape.tree, ape.dat, model='OUM')
            results[row,] <-
                c(ou.tree@nterm,
                  as.numeric(sapply(c('1','2'),function(x)sum(ou.reg[ou.tree@term]==x))),
                  as.numeric(summary(ou.OU)$aic),
                  as.numeric(summary(ou.OU)$alpha),
                  as.numeric(summary(ou.OU)$sigma.sq),
                  as.numeric(summary(ou.OU)$optima$val),
                  ape.OUM$AIC,
                  ape.OUM$solution[1,1],
                  ape.OUM$solution[2,2],
                  ape.OUM$theta[1:2,1])
            row <- row+1
        }
    }
    colnames(results) <- c('ntips','nreg1','nreg2','ouch.aic','ouch.alpha','ouch.sigma.sq','ouch.th1','ouch.th2','ouwie.aic','ouwie.alpha','ouwie.sigma.sq','ouwie.th1','ouwie.th2')
    results <- as.data.frame(results)
    save(results, file='Comparing_OUwie_and_ouch_results.rda')
}
@
\end{document}
