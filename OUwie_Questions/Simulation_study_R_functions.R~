
## Creates an ouchtree object.  waittime must be specified by the
## user, and is the expected time to a branching event, assuming the
## branching follows a Poisson process (that is, that branching events
## are exponentially distributed). endtime must also be specified and
## determines how long to let the branching process proceed. The
## smaller the value of waittime, or the larger the value of endtime,
## the larger the tree that will be produced. If only these two
## variables are set, the tree that is produced will be ultrametric;
## specifically, it will be a Yule tree, corresponding to a pure birth
## process. time can also be specified, setting the time of the root
## node.  A birth-death branching process can be simulated by setting
## the value of extrate, which determines the rate at which lineages
## go extinct. This rate is also assumed to be exponentially
## distributed.
gen.tree <- function(waittime, endtime, time = 0, extrate = 0, anc.node = NA, tree) {
  if (missing(tree))
    tree <- matrix(NA,0,3,dimnames=list(NULL,c("node","ancestor","time")))
  curr.node <- nrow(tree)+1
  if (time < endtime) {
    tree <- rbind(tree,c(curr.node,anc.node,time))
    extinct.time <- if (extrate > 0) {
      time+rexp(2,rate=extrate)
    } else {
      c(Inf,Inf)
    }
    time <- pmin(time+rexp(2,rate=1/waittime),endtime)
    for (k in 1:2) {
      if (time[k] < extinct.time[k]) {
        tree <- Recall(time=time[k],waittime=waittime,endtime=endtime,extrate=extrate,anc.node=curr.node,tree=tree)
      } else {
        tree <- rbind(tree,c(nrow(tree)+1,curr.node,extinct.time[k]))
      }
    }
  } else {
    tree <- rbind(tree,c(curr.node,anc.node,time))
  }
  return(as.data.frame(tree))
}

## process, given an ouchtree object specified by tree, regimes
## specified by regimes, and OU parameters theta, alpha, and sigma.
## This is done by recursion, which gen.phenotypic.values acting as
## the "parent" function that calls set.phenotypic.values, the
## function that is recursed over.
gen.phenotypic.values <- function(tree, regimes, theta, alpha, sigma, remove.anc=TRUE) {
  if (class(tree) == 'data.frame')
    tree <- with(tree, ouchtree(node,ancestor,time))
  if (tree@nnodes != length(regimes))
    stop('Length of regime specification != number of nodes in tree; each node in tree must be assigned to a regime')
  if (length(theta) != length(levels(regimes)))
    stop('Each regime must have a unique theta value specified as the selective optima')

  root.reg <- as.numeric(regimes[1])
  root.pheno <- calc.root.pheno(theta[root.reg], alpha, sigma)
  pheno <<- vector(mode='numeric', length=tree@nnodes)
  set.phenotypic.values(curr.node=1, anc.node=0, anc.pheno=root.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)

  ## if T, set the phenotypic values of internal nodes to NA
  if (remove.anc==T)
    pheno[as.numeric(setdiff(tree@nodes, tree@term))] <<- NA

  pheno
}
## Calculate the phenotypic value of the ancestral node as being drawn
## from the stationary distribution of the OU process.
calc.root.pheno <- function(theta, alpha, sigma) {
  ## mean and variance of stationary distribution
  mean <- theta
  var <- sigma^2/(2*alpha)
  rnorm(1, mean=mean, sd=sqrt(var))
}
## This function recursively sets the phenotypic values of the nodes
## in an ouchtree object specified by tree.  The values are, by
## default, set for a vector called 'pheno'
set.phenotypic.values <- function(curr.node, anc.node, anc.pheno, tree, regimes, theta, alpha, sigma) {
  ## set the phenotype of the current node
  if (curr.node == 1) {
    pheno[curr.node] <<- anc.pheno

    ## get the descendents of the root node and set their phenotypes
    desc <- which(tree@ancestors==curr.node)
    Recall(curr.node=desc[1], anc.node=curr.node, anc.pheno=anc.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
    Recall(curr.node=desc[2], anc.node=curr.node, anc.pheno=anc.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
  }
  else {
    ## generate a new phenotypic value
    x0 <- anc.pheno
    t <- as.numeric(tree@times[curr.node])-as.numeric(tree@times[anc.node])
    th <- theta[as.numeric(levels(regimes)[regimes[curr.node]])]
    a <- alpha
    p <- x0*exp(-a*t) + th*(1-exp(-a*t)) +
      sigma*sqrt((1-exp(-2*a*t))/(2*a))*rnorm(1, 0, 1)

    ## set the value of the phenotype
    pheno[curr.node] <<- p

    ## if the curr.node is not a tip, get its ancestors and set their
    ## phenotypes
    if (!(curr.node %in% tree@term)) {
      desc <- which(tree@ancestors==curr.node)

      ## set the phenotypes for all descendents
      for (n in 1:length(desc))
        Recall(curr.node=desc[n], anc.node=curr.node, anc.pheno=p, tree=tree,
               regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
    }
  }
}
