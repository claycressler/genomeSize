\documentclass[12pt,reqno,final]{amsart}
\usepackage[round,numbers,sort&compress]{natbib}
\usepackage{graphicx}
\usepackage{times}
\usepackage{rotating}
\usepackage{subfig}

\title[]{}

\setlength{\textwidth}{6.25in}
\setlength{\textheight}{8.75in}
\setlength{\evensidemargin}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\topmargin}{-.35in}
\setlength{\parskip}{.1in}
\setlength{\parindent}{0.0in}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{corol}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{defn}[thm]{Definition}
\newtheorem{hyp}[thm]{Hypothesis}
\newtheorem{example}[thm]{Example}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{algorithm}[thm]{Algorithm}
\newtheorem{remark}{Remark}
\renewcommand\thethm{\arabic{thm}}
\renewcommand{\theremark}{}

\numberwithin{equation}{part}
\renewcommand\theequation{\arabic{equation}}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thefigure{\arabic{figure}}
\renewcommand\thetable{\arabic{table}}
\renewcommand\thefootnote{\arabic{footnote}}

\begin{document}

\maketitle

This documents my exploration of the differences between
\texttt{OUwie} and \texttt{ouch} when each is asked to fit OU models
with a single $\alpha$ and $\sigma$ operating on the entire tree. The
motivation for this is that I noticed that the parameter estimates and
likelihoods reached by \texttt{OUwie} and \texttt{ouch} are often
quite different.

The procedure I will follow here is very straightforward: generate
Yule trees of different sizes; specify two selective regimes arising
out of the branching event at the root, so that there is a single
monophyletic clade in each selective regime - this is the simplest
possible multiple-optimum OU scenario; simulate phenotypic data with a
known $\alpha$ and $\sigma$; fit an OU model to the phenotypic data
and tree using both \texttt{OUwie} and \texttt{ouch} and record the
parameter estimates and likelihoods.

Trees were generated by assuming that branching follows a Poisson
process, so that branching events are exponentially distributed. To
generate trees of different sizes, I set the rate parameter of
the exponential distribution to a value of 0.3 and found random number
generator seeds that would generate trees of size from 10 to 100 tips,
with the only constraint being that the smaller of the two clades
originating at the root had at least 1/3 of the total tip
species. This guarantees that both selective regimes are reasonably
well-represented, thereby improving both power and parameter
estimates.

Phenotypic data was generated assuming $\alpha=3$ and $\sigma^2=1$,
with selective optima of $\theta_1=-1$ and $\theta_2=1$. The root was
always assumed to be in regime 1. For any given tree size, 20
different phenotypic datasets were generated and fit to the OU
model. This allows me to calculate how bias/variance in parameter
estimates differ between the two algorithms. All of the code,
including random number generator seeds, needed to reproduce the
results shown here can be found at the end of this document.

\begin{figure}
<<echo=T,fig=T>>=
require(ggplot2)
load(file='Comparing_OUwie_and_ouch_results.rda')
##
alpha <- data.frame(alpha=c(results$ouch.alpha,results$ouwie.alpha),
                   Tips=rep(results$ntips,2),
                   Model=factor(rep(c('ouch','OUwie'),each=nrow(results))))
## Remove all estimates that were stuck on the boundary
alpha <- alpha[alpha$alpha > 0.0001 & alpha$alpha < 10,]

ggplot(alpha, aes(Tips, alpha, group=Model, colour=Model)) + stat_smooth() + geom_hline(yintercept=3)

## Interestingly, I am finding that ouch is having a hard time estimating the parameters (as is ouwie) - it tends to overestimate alpha by quite a wide margin. I wonder if this is because of the oversimplified regime painting and high alpha - the data are actually too simple for ouch to sink its teeth in. similar to the Ho and Ane finding that theta cannot be consistently estimated on a single OU tree. Variation among tip species that are in the same regime is what it thrives on, but there would essentially be no variation among the tips in this simple scenario: the pattern would be consistent with any number of alpha/sigma.sq combinations.
plot(results$ouch.alpha/results$ouch.sigma.sq)
abline(h=3, col=2)
## You can see that it is essentially pegging the stationary variance, as you would expect. Because there is no variation among the clades, it actually has a hard time telling alpha and sigma, but it can peg the ratio.
plot(results$ouwie.alpha/results$ouwie.sigma.sq)
abline(h=3, col=2)
## ouwie does this as well, but even better, frankly.

## So what about the theta estimates, then?



@
\caption{Comparing the $\alpha$ estimates of \texttt{ouch} and
  \texttt{OUwie} for trees of 10-40 tips. Esimates are presented on the $\log_{10}$ scale. The
  black line shows the true $\alpha$ value.}
\label{fig:alpha}
\end{figure}

Overall, \texttt{ouch} converged on parameter estimates with a lower
AIC in 1030/1820 (57\%) datasets; for 765 of those datasets, the AIC
was more than two units lower. Of the 790 datasets where
\texttt{OUwie} converged on parameter estimates with a lower AIC, the
maximum difference in log-likelihood was only 0.95, indicating that
even when \texttt{OUwie} converged to a parameter set with a higher
likelihood, the difference was slight. In general, these results
suggest that \texttt{ouch} is more likely to converge on the MLE than
\texttt{OUwie}.

In terms of parameter estimates, for 231/1820 (12.7\%) of datasets,
the $\alpha$ estimate returned by \texttt{OUwie} was on the lower
boundary ($1 \times 10^{-6}$). This happened across a huge range of
tree sizes (12 to 98 tips). The observed estimates are shown in
Figs. \ref{fig:alpha}-\ref{fig:alpha3}. You can see that, in general,
the variance in $\alpha$ estimates is much lower for \texttt{ouch}
than \texttt{OUwie}

<<echo=T>>=
require(ouch)
## Creates an ouchtree object.  waittime must be specified by the
## user, and is the expected time to a branching event, assuming the
## branching follows a Poisson process (that is, that branching events
## are exponentially distributed). endtime must also be specified and
## determines how long to let the branching process proceed. The
## smaller the value of waittime, or the larger the value of endtime,
## the larger the tree that will be produced. If only these two
## variables are set, the tree that is produced will be ultrametric;
## specifically, it will be a Yule tree, corresponding to a pure birth
## process. time can also be specified, setting the time of the root
## node.  A birth-death branching process can be simulated by setting
## the value of extrate, which determines the rate at which lineages
## go extinct. This rate is also assumed to be exponentially
## distributed.
gen.tree <- function(waittime, endtime, time = 0, extrate = 0, anc.node = NA, tree) {
  if (missing(tree))
    tree <- matrix(NA,0,3,dimnames=list(NULL,c("node","ancestor","time")))
  curr.node <- nrow(tree)+1
  if (time < endtime) {
    tree <- rbind(tree,c(curr.node,anc.node,time))
    extinct.time <- if (extrate > 0) {
      time+rexp(2,rate=extrate)
    } else {
      c(Inf,Inf)
    }
    time <- pmin(time+rexp(2,rate=1/waittime),endtime)
    for (k in 1:2) {
      if (time[k] < extinct.time[k]) {
        tree <- Recall(time=time[k],waittime=waittime,endtime=endtime,extrate=extrate,anc.node=curr.node,tree=tree)
      } else {
        tree <- rbind(tree,c(nrow(tree)+1,curr.node,extinct.time[k]))
      }
    }
  } else {
    tree <- rbind(tree,c(curr.node,anc.node,time))
  }
  return(as.data.frame(tree))
}

## Generate phenotypic data according to an Ornstein-Uhlenbeck
## process, given an ouchtree object specified by tree, regimes
## specified by regimes, and OU parameters theta, alpha, and sigma.
## This is done by recursion, which gen.phenotypic.values acting as
## the "parent" function that calls set.phenotypic.values, the
## function that is recursed over.
gen.phenotypic.values <- function(tree, regimes, theta, alpha, sigma, remove.anc=TRUE) {
  if (class(tree) == 'data.frame')
    tree <- with(tree, ouchtree(node,ancestor,time))
  if (tree@nnodes != length(regimes))
    stop('Length of regime specification != number of nodes in tree; each node in tree must be assigned to a regime')
  if (length(theta) != length(levels(regimes)))
    stop('Each regime must have a unique theta value specified as the selective optima')

  root.reg <- as.numeric(regimes[1])
  root.pheno <- calc.root.pheno(theta[root.reg], alpha, sigma)
  pheno <<- vector(mode='numeric', length=tree@nnodes)
  set.phenotypic.values(curr.node=1, anc.node=0, anc.pheno=root.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)

  ## if T, set the phenotypic values of internal nodes to NA
  if (remove.anc==T)
    pheno[as.numeric(setdiff(tree@nodes, tree@term))] <<- NA

  pheno
}
## Calculate the phenotypic value of the ancestral node as being drawn
## from the stationary distribution of the OU process.
calc.root.pheno <- function(theta, alpha, sigma) {
  ## mean and variance of stationary distribution
  mean <- theta
  var <- sigma^2/(2*alpha)
  rnorm(1, mean=mean, sd=sqrt(var))
}
## This function recursively sets the phenotypic values of the nodes
## in an ouchtree object specified by tree.  The values are, by
## default, set for a vector called 'pheno'
set.phenotypic.values <- function(curr.node, anc.node, anc.pheno, tree, regimes, theta, alpha, sigma) {
  ## set the phenotype of the current node
  if (curr.node == 1) {
    pheno[curr.node] <<- anc.pheno

    ## get the descendents of the root node and set their phenotypes
    desc <- which(tree@ancestors==curr.node)
    Recall(curr.node=desc[1], anc.node=curr.node, anc.pheno=anc.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
    Recall(curr.node=desc[2], anc.node=curr.node, anc.pheno=anc.pheno, tree=tree, regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
  }
  else {
    ## generate a new phenotypic value
    x0 <- anc.pheno
    t <- as.numeric(tree@times[curr.node])-as.numeric(tree@times[anc.node])
    th <- theta[as.numeric(levels(regimes)[regimes[curr.node]])]
    a <- alpha
    p <- x0*exp(-a*t) + th*(1-exp(-a*t)) +
      sigma*sqrt((1-exp(-2*a*t))/(2*a))*rnorm(1, 0, 1)

    ## set the value of the phenotype
    pheno[curr.node] <<- p

    ## if the curr.node is not a tip, get its ancestors and set their
    ## phenotypes
    if (!(curr.node %in% tree@term)) {
      desc <- which(tree@ancestors==curr.node)

      ## set the phenotypes for all descendents
      for (n in 1:length(desc))
        Recall(curr.node=desc[n], anc.node=curr.node, anc.pheno=p, tree=tree,
               regimes=regimes, theta=theta, alpha=alpha, sigma=sigma)
    }
  }
}

run <- FALSE;
if (run) {
    ## The code for finding the RNG seeds to use to create the trees
    seeds <- rep(NA,length=length(seq(10,100)))
    while(sum(is.na(seeds))!=0) {
        print(sum(is.na(seeds)))
        seed <- floor(runif(1, 1, 1e7))
        set.seed(seed)
        tree <- gen.tree(waittime=0.3, endtime=1)
        labels <- rep('', nrow(tree))
        labels[which(tree$time==1)] <- paste0('Sp',1:sum(tree$time==1))
        tree$labels <- labels
        ou.tree <- ouchtree(nodes=tree$node, ancestors=tree$ancestor, times=tree$time, labels=tree$labels)
        ## If the tree has a number of tips that is not currently included in the set of RNG seeds...
        if (ou.tree@nterm%in%seq(10,100))
            if (is.na(seeds[which(seq(10,100)%in%ou.tree@nterm)])) {
                ## ...paint regimes on the tree and...
                ou.reg <- paint(ou.tree, subtree=c('1'='1','2'='2'), branch=c('1'='1','2'='2'))
                ## ...if the number of tips in the smallest regime is at least 1/3 the size of the tree...
                if (min(sapply(c('1','2'), function(x) sum(ou.reg[ou.tree@term]==x))) >= ou.tree@nterm/3)
                    ## ...record the seed
                    seeds[which(seq(10,100)%in%ou.tree@nterm)] <- seed
            }
    }

    ## The actual seeds used to generate the trees
    seeds <- c(35250,48305,512,9741,10942,82785,3690754,52887,2694830,31665,42307,64469,35257,68441,92488,91977,35279,63427,46032,64842,20056,13808,68427,79904,36216,762795,79173,59583,47372,7590702,90416,73212,33918,99829,35133,83037,34561,1252,77451,21182,68657,80080,58622,23352,92605,61669,94680,70448,62496,86767,50532,32082,6873,52895,52446,59809,50041,69135,87196,16166,35368,6690,57828,532,12679,55138,50109,45607,97207,11457,17776,421650,46569,67892,3646,80656,3812264,78324,88179,2143,3091624,4407,30378,2489714,5983027,57710,13597,10252,91772,70484,4685585)

    ## Seeds for generating phenotypic datasets
    pseeds <- c(429561,582711,910097,733148,536289,732902,397913,193437,466449,731455,229950,492461,462732,95019,379477,553164,806700,771928,524934,268107)

    require(pmc) ## for converting trees of class 'ouchtree' to trees of class 'phylo'
    results <- array(NA, dim=c(length(seeds)*length(pseeds),13))
    row <- 1
    for (i in 1:length(seeds)) {
        print(i)
        seed <- seeds[i]
        set.seed(seed)
        tree <- gen.tree(waittime=0.3, endtime=1)
        labels <- rep('', nrow(tree))
        labels[which(tree$time==1)] <- paste0('Sp',1:sum(tree$time==1))
        tree$labels <- labels
        ou.tree <- ouchtree(nodes=tree$node, ancestors=tree$ancestor, times=tree$time, labels=tree$labels)
        ou.reg <- paint(ou.tree, subtree=c('1'='1','2'='2'), branch=c('1'='1', '2'='2'))

        ape.tree <- convert(ot=ou.tree)
        ## Label the internal nodes with their regime
        ## figure out which clade is in regime 2
        ## root is ntips+1, find its daughters
        daughters <- which(ape.tree$edge[,1]==ou.tree@nterm+1)
        ## which daughter corresponds to node 2 in the ouchtree?
        node2 <- which(round(ape.tree$edge.length[daughters],4)==round(ou.tree@times[2],4))
        ## what is the nodelabel for this daughter
        start <- ape.tree$edge[daughters[node2],2]
        ## what is the nodelabel for the other daughter?
        finish <- ape.tree$edge[daughters[-node2],2]
        ## create node.labels
        nodes <- (ou.tree@nterm+1):(ape.tree$Nnode+ou.tree@nterm)
        regs <- rep('1', length(nodes))
        reg2 <- start:(finish-1)
        regs[which(nodes%in%reg2)] <- '2'
        ape.tree$node.label <- regs

        ## Plot trees to ensure that the trees and paintings are identical
        ## plot(ou.tree, regimes=ou.reg)
        ## par(ask=T)
        ## plot(ape.tree)
        ## nodelabels(pch=21, bg=ape.tree$node.label)

        for (j in 1:length(pseeds)) {
            set.seed(pseeds[j])
            ## simulate phenotypic data
            x <- gen.phenotypic.values(ou.tree, ou.reg, theta=c(-1,1), alpha=3, sigma=1)
            ## create data frames of phenotypic data
            ou.dat <- data.frame(val=x)
            ape.dat <- as(ou.tree, 'data.frame')[,c(4,1,2,3)]
            ape.dat$val <- x
            ape.dat$reg <- ou.reg
            ape.dat <- ape.dat[!is.na(ape.dat$val),c('labels','reg','val')]

            ## fit OU model using ouch and OUwie and record
            ou.OU <- hansen(ou.dat, ou.tree, ou.reg, sqrt.alpha=1, sigma=1)
            ape.OUM <- OUwie(ape.tree, ape.dat, model='OUM')
            results[row,] <-
                c(ou.tree@nterm,
                  as.numeric(sapply(c('1','2'),function(x)sum(ou.reg[ou.tree@term]==x))),
                  as.numeric(summary(ou.OU)$aic),
                  as.numeric(summary(ou.OU)$alpha),
                  as.numeric(summary(ou.OU)$sigma.sq),
                  as.numeric(summary(ou.OU)$optima$val),
                  ape.OUM$AIC,
                  ape.OUM$solution[1,1],
                  ape.OUM$solution[2,2],
                  ape.OUM$theta[1:2,1])
            row <- row+1
        }
    }
    colnames(results) <- c('ntips','nreg1','nreg2','ouch.aic','ouch.alpha','ouch.sigma.sq','ouch.th1','ouch.th2','ouwie.aic','ouwie.alpha','ouwie.sigma.sq','ouwie.th1','ouwie.th2')
    results <- as.data.frame(results)
    save(results, file='Comparing_OUwie_and_ouch_results.rda')
}
@
\end{document}
